package ibm

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/hashicorp/terraform/helper/schema"
	"github.com/softlayer/softlayer-go/datatypes"
	"github.com/softlayer/softlayer-go/helpers/location"
	"github.com/softlayer/softlayer-go/services"
	slsession "github.com/softlayer/softlayer-go/session"
	"github.com/softlayer/softlayer-go/sl"
)

func resourceIBMMultiVlanFirewall() *schema.Resource {
	return &schema.Resource{
		Create:   resourceIBMNetworkMultiVlanCreate,
		Read:     resourceIBMComputeSSHKeyRead,
		Update:   resourceIBMComputeSSHKeyUpdate,
		Delete:   resourceIBMComputeSSHKeyDelete,
		Exists:   resourceIBMComputeSSHKeyExists,
		Importer: &schema.ResourceImporter{},

		Schema: map[string]*schema.Schema{
			"datacenter": {
				Type:     schema.TypeString,
				Required: true,
			},

			"pod": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
					return strings.TrimSpace(old) == strings.TrimSpace(new)
				},
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
			},

			"firewall_type": {
				Type:     schema.TypeString,
				Required: true,
			},

			"addon_configuration": {
				Type:     schema.TypeList,
				Elem:     &schema.Schema{Type: schema.TypeString},
				Required: true,
			},
		},
	}
}

//Autogenerated is used for testing purposes
type AutoGenerated struct {
	FrontendRouterID int `json:"frontendRouterId"`
}

func resourceIBMNetworkMultiVlanCreate(d *schema.ResourceData, meta interface{}) error {
	sess := meta.(ClientSession).SoftLayerSession()
	name := d.Get("name").(string)
	firewalltype := d.Get("firewall_type").(string)
	datacenter := d.Get("datacenter").(string)
	pod := d.Get("pod").(string)
	id := datacenter + "." + pod
	foo := new(AutoGenerated)
	_, err := getRequest("https://api.softlayer.com/rest/v3.1/SoftLayer_Network_Pod/"+id+"/getObject.json?objectMask=mask[frontendRouterId]", sess, foo)
	if err != nil {
		return fmt.Errorf("No response got")
	}
	routerid := foo.FrontendRouterID
	//resp1, err2 := datacenterservice.Filter(datacenterfilter).Mask(datacentermask).GetDatacenters()
	datacenter123, ok := d.GetOk("datacenter")
	if !ok {
		return fmt.Errorf("The attribute datacenter is not defined")
	}
	//get the datacenter id
	dc, err := location.GetDatacenterByName(sess, datacenter123.(string), "id")
	if err != nil {
		return fmt.Errorf("Datacenter not found")
	}
	locationservice := services.GetLocationService(sess)
	//get the pricegroups that the datacenter belongs to
	priceidds, _ := locationservice.Id(*dc.Id).GetPriceGroups()
	var s []int
	//store all the pricegroups a datacenter belongs to
	for _, priceidd := range priceidds {
		s = append(s, *priceidd.Id)
	}
	addonconfigurations, ok := d.Get("addon_configuration").([]interface{})
	var actualaddons []string
	for _, addons := range addonconfigurations {
		actualaddons = append(actualaddons, addons.(string))
	}
	actualaddons = append(actualaddons, firewalltype, "20000 GB Bandwidth")
	if firewalltype != "FortiGate Security Appliance" {
		actualaddons = append(actualaddons, "FortiGate Security Appliance")
	}
	if !ok {
		return fmt.Errorf("Couldnt convert addons")
	}
	priceItems := []datatypes.Product_Item_Price{}
	for _, priceid := range actualaddons {
		actualpriceid, err := returnpriceidaccordingtopackageid(priceid, s, sess)
		if err != nil || actualpriceid == 0 {
			return fmt.Errorf("Erorr in returnpriceidaccordingtopackageid")
		}
		priceItem := datatypes.Product_Item_Price{
			Id: &actualpriceid,
		}
		priceItems = append(priceItems, priceItem)
	}
	packageid := 863
	Complextype := "SoftLayer_Container_Product_Order_Network_Protection_Firewall_Dedicated"
	productOrderContainer := datatypes.Container_Product_Order_Network_Protection_Firewall_Dedicated{
		Container_Product_Order: datatypes.Container_Product_Order{
			PackageId:   &packageid,
			Prices:      priceItems,
			Quantity:    sl.Int(1),
			Location:    &datacenter,
			ComplexType: &Complextype,
		},
		Name:     sl.String(name),
		RouterId: &routerid,
	}
	_, err = services.GetProductOrderService(sess.SetRetries(0)).
		VerifyOrder(&productOrderContainer)
	if err != nil {
		return fmt.Errorf("Error during Verify order for Creating: %s", err)
	}
	/*
		_, err = services.GetProductOrderService(sess.SetRetries(0)).
			PlaceOrder(&productOrderContainer, sl.Bool(false))
		if err != nil {
			return fmt.Errorf("Error during Verify order for Creating: %s", err)
		}*/
	return err
}
func returnpriceidaccordingtopackageid(appliance string, pricegroupid []int, sess *slsession.Session) (int, error) {
	productpackageservice := services.GetProductPackageService(sess)
	productpackageservicefilter := strings.Replace("{\"items\":{\"description\":{\"operation\":\"appliance\"}}}", "appliance", appliance, -1)
	resp, err := productpackageservice.Mask("description,prices.locationGroupId,prices.id").Filter(productpackageservicefilter).Id(863).GetItems()
	if err != nil {
		return 0, fmt.Errorf("Eroor in returnpriceidaccordingtopackageid")
	}
	m := make(map[int]int)
	for _, item := range pricegroupid {
		for _, items := range resp {
			for _, temp := range items.Prices {
				if temp.LocationGroupId == nil {
					m[item] = *temp.Id
				} else if item == *temp.LocationGroupId {
					m[*temp.LocationGroupId] = *temp.Id
				}
			}
		}
		if val, ok := m[item]; ok {
			return val, nil
		}
	}
	return 0, nil
}
func getRequest(requestpath string, session *slsession.Session, target interface{}) (body string, error error) {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	request, err := http.NewRequest("GET", requestpath, nil)
	if err != nil {
		log.Printf("[ERROR] Error in creating http Request %s", err)
		return "", fmt.Errorf("[ERROR] Error in creating request %s", err.Error())
	}
	request.SetBasicAuth(session.UserName, session.APIKey)
	request.Header.Set("Accept", "application/json")
	request.Header.Set("Content-Type", "application/json")
	client := &http.Client{Transport: tr}
	resp, err := client.Do(request)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	return "", json.NewDecoder(resp.Body).Decode(target)
}
